###  进程  
#### 进程的概念  
在计算机中,程序通常是普通文件--一个为了完成特定任务而准备好的指令序列与数据的集合,以'可执行映像'的格式保存在磁盘中.再经过编译器编译后,可以生成对应的可执行文件或可执行程序.  
而进程则是程序执行的具体实例:一个程序在执行过程中就是一个进程,直至执行完毕.在执行过程中进程享有系统的各种资源,如:运行环境,CPU,外设,内存,进程ID等;当执行完毕后,进程会被销毁;程序可以实例化多个进程;LINUX环境下可以通过 'ps' 命令查看当前正在执行的程序.  
程序到进程的转换的过程大致如下:  
* 查找命令对应程序文件的位置;  
* 使用fork()函数为其启动一个新进程;  
* 在新进程中调用 'exec' 族函数装载程序文件,并执行程序文件中的main();  

程序与进程的关系:  
* 程序是一系列指令序列与数据的集合,本质是个静态实体.进程是程序在某个数据集上的执行过程,是个动态运行的实体;  
* 程序与进程并不一一对应:一个程序执行在不同的数据集上运行就会成为不同的进程,可使用进程控制块来唯一地标识系统中的每个进程;  
* 进程具有并发性而程序没有;  
* 进程是竞争计算机资源的基本单位为程序不是;  

#### 进程的状态  
##### 状态标识  
通过使用 'ps -ux' 命令查看当前进程状态.  
| 状态 | 说明 |
| :----: | :---- |
| R | 运行状态: 可运行状态,表示进程在运行队列中,处于正在执行或即将运行状态,只有处于这种状态的进程才可能在CPU上运行,同一时刻可能有多个进程处于该状态. |
| S | 可中断的睡眠状态: 通常是因为等待某种事件发生而被挂起,如进程在等待信号. |
| D | 不可中断的睡眠状态: 通常在等待输入/输出完成,这种状态下进程不能响应异步信号. |
| T | 停止状态: 通常是被shell的工作信号控制,或被追踪处于调试器的控制下. |
| Z | 退出状态: 进程成为僵尸进程. |
| X | 退出状态: 进程即将被回收. |
| s | 进程是会话其首进程. |
| l | 进程是多线程的. |
| + | 进程属于前台进程组. |
| < | 高优先级任务. |

##### 状态转换
* 通常情况下,一个进程的开都是由其父进程调用fork()函数开始的;而在系统开始运行时,init()函数就开始运行,在系统运行过程中,会不断启动新的进程,这些进程要么是init进程直接启动的,要么是被init进程启动的其他进程所启动;  
* 一个进程被启动后就处于可执行状态(但未必占用CPU运行).在进程等待队列中排队的被称为:就绪态;占用CPU运行的状态被称为:运行态;  
* 当系统产生进程调度时,处于就绪态的进程可以获取CPU的使用权,转入运行态;但由于时间片的限制,每个进程的运行时间都是有限的,如果在超出时间片就会被系统重新放入等待队列中进行等待,此时进程转为就绪态,等待下一次进程调度;另外,即使运行态进程并未使用完时间片,也有可能被更高级别的进程抢占资源而被迫重新等待;  
* 运行态进程可能会因为等待某些事件,信号或资源而进入可中断睡眠态,如进程要读取管道数据但此时管道为空,或需要获取一个锁资源但当前锁不可获取,又或者是通过调用sleep()函数强制进入睡眠状态.而在特定条件发生后,进程又会转入就绪态.  
* 运行态进程也可能会进程不可中断睡眠态,这种状态下进程不能响应信号,一般这种状态的进程都是在等待输入或输出.  
* 进程完成任务后会退出,并进入退出状态,如:在main()函数中调用return或exit等,属于正常退出.如收到kill信号进程被 '杀死' ,属于异常退出.不论是否异常退出,内核都会调用do_exit()函数是进程转为僵尸态.进程在退出时系统会将其退出信号--推出值,被什么信号结束等--保存在进程控制块(Process Control Block)中,等待父进程查看这些信息.  
* 当父进程处理僵尸进程时,会将其状态设为EXIT_DEAD(死亡态),之后子系统才能回收僵尸进程的内存空间.当父进程比子进程先退出时,子进程将被其祖先进程init进程 '收养' (adopt),并待其推出后回收其资源.  

#### 启动新进程  
LInux启动一个新进程有多种方式如: system(),fork()等.  
##### system方式  
C标准库(stdlib.h)提供了system(),这是一种调用其他程序的简单方法,事实上system()启动了一个运行着/bin/sh的子进程,然后将命令交由其执行.函数原型如下:
```C
int system(const char *_Command);
```
'\_Command' 参数是字符串形式的shell命令.  
返回值:  
* 命令成功执行,返回一个非零值,通常是命令的退出状态码;  
* 如果命令无法执行或执行出错,返回 -1;  
* 如果无法执行命令解释器,返回一个错误值;  
因为这种方式收到系统shell自身功能特性和安全缺陷的限制,所以不推荐使用.  

##### fork方式  
C标准库(unistd.h)提供了fork(),其基础功能是从原进程中创建一个完全一致的分离进程.函数原型如下:
```C
pid_t fork(void);
```
返回值--籍此判断父子进程:  
* 调用失败返回 -1;  
* 父进程将被返回子进程的进程ID(一个大于0的整数值);  
* 子进程将被返回 0;  

父子进程相同的内容:  
* 进程的地址空间;  
* 进程上下文,代码段;  
* 进程堆空间,栈空间,内存信息;  
* 进程的环境变量;  
* 标准IO的缓冲区;  
* 打开的文件描述符;  
* 信号响应函数;  
* 当前工作路径;  

子进程独有的内容:  
* 进程号PID;  
* 记录锁--如果父进程对某文件加锁,子进程不会继承这把锁;  
* 挂起的信号--这些已经响应但尚未处理的信号不会被继承;  

###### 写时复制  
COW--Copy On Write:因为子进程几乎是父进程的完全复制,所以会运行同一个程序,所以在复制时会消耗大量资源与时间.因此父子进程会共享页面,只有在需要写入时才会复制地址空间,而绝大数情况下共享页面并不会被写入.  

##### exec系列  
因为fork函数启动一个相同的子进程并没有意义,因此诞生了exec系列函数(<unistd.h>)用于替换进程的执行程序,它根据指定的文件名或目录名查找可执行文件,并用其取代原调用进程的数据段,代码段和堆栈段,执行完后除进程号其余内容被新程序内容替换.  
```C
int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ..., char *const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
```

#### 终止进程  
Linux系统中,进程终止的常见方式有五种:  
* 正常终止:  
    - 从main()函数返回;  
    - 调用exit()函数终止;  
    - 调用_exit()函数终止;  
* 异常终止:  
    - 调用abort()函数终止;
    - 由系统信号终止;

Linux系统下,exit()函数定义在stdlib.h中,\_exit()定义在unistd.h中,二者都是用于终止进程,当程序执行到这两个函数时,进程将无条件停止剩余的所有操作,清除包括PCB在内的各种数据结构,并终止当前进程.二者最大的区别在于前者会将缓冲区的数据写入文件,后者则不会.  

#### 等待进程  
Linux环境中,当使用fork()函数启动一个子进程时,子进程就拥有自己的生命周期并独立运行.而如果父进程想了解子进程是否结束或结束的状态甚至等待子进程结束,可以通过调用wait()或waitpid()函数让函数等待子进程的结束;并且调用这两个函数也是回收僵尸进程的方式.  

##### wait函数  
wait函数在<sys/wait.h>头文件中,原型如下:  
```C
pid_t wait(int *wstatus);
```
wait函数在被调用时,父进程将被暂替直至信号来到或子进程结束,如果子进程已经结束则将返回子进程结束状态值.函数返回子进程PID,参数 'wstatus' 将传入结束状态信息,如果不在意结束状态信息可以传入 'NULL'.该函数需要与fork函数配合使用,如果在fork函数前使用wait函数将返回 -1.  

##### waitpid函数  
waitpid函数在<sys/wait.h>头文件中,原型如下:  
```C
pid_t waitpid(pid_t pid, int *wstatus, int options);
```
参数:  
* pid: 
    - pid < -1:等待进程组号为pid绝对值的任何子进程;  
    - pid = -1:等待任何子进程,此时等同于wait函数;  
    - pid = 0:等待进程组好与目前进程相同的任何子进程;
    - pid > 0:等待指定pid的子进程;
* wstatus:同wait函数相同;  
* options:
    - WNOHANG:如果子进程未终止或未接收到指定的信号,则立即返回而不阻塞;
    - WUNTRACED:报告已终止的子进程，即使它们是由信号而不是exit函数调用终止的;
    - WCONTINUED:报告已继续的子进程;
    - 0:不添加选项;